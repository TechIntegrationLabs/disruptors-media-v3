const BaseAgent = require('./base-agent');
const path = require('path');

class PerformanceAuditorAgent extends BaseAgent {
  constructor(context) {
    super(context);
    this.performanceConfig = {
      metrics: {
        lighthouse: {
          performance: { threshold: 90, weight: 0.25 },
          accessibility: { threshold: 95, weight: 0.20 },
          bestPractices: { threshold: 95, weight: 0.20 },
          seo: { threshold: 95, weight: 0.15 },
          pwa: { threshold: 80, weight: 0.20 }
        },
        webVitals: {
          FCP: { threshold: 1.8, unit: 's' },   // First Contentful Paint
          LCP: { threshold: 2.5, unit: 's' },   // Largest Contentful Paint
          FID: { threshold: 100, unit: 'ms' },  // First Input Delay
          CLS: { threshold: 0.1, unit: '' }     // Cumulative Layout Shift
        },
        bundle: {
          maxSize: 250, // KB
          gzipRatio: 0.3,
          chunkSizeLimit: 100 // KB
        }
      },
      optimizations: {
        images: ['webp', 'lazy-loading', 'responsive', 'compression'],
        code: ['tree-shaking', 'code-splitting', 'minification', 'compression'],
        assets: ['caching', 'cdn', 'preloading', 'compression'],
        network: ['http2', 'compression', 'connection-pooling']
      },
      monitoring: {
        interval: 3600000, // 1 hour
        endpoints: ['/', '/about', '/services', '/contact'],
        reportRetention: 30 // days
      }
    };
    this.performanceReports = [];
    this.optimizationQueue = [];
    this.performanceHistory = new Map();
  }

  async execute() {
    try {
      await this.setupExecution();
      
      const { trigger, context } = this.context;
      
      switch (trigger) {
        case 'interval':
          await this.performScheduledAudit();
          break;
        case 'keyword':
          await this.handleKeywordTrigger(context.keyword);
          break;
        case 'manual':
          await this.performComprehensiveAudit();
          break;
        default:
          this.log(`Unknown trigger type: ${trigger}`);
      }
      
      await this.cleanupExecution();
    } catch (error) {
      this.error('Failed to execute performance auditor agent', error);
      throw error;
    }
  }

  async setupExecution() {
    // Initialize performance monitoring
    await this.loadPerformanceHistory();
    await this.checkDependencies();
    await this.initializeMonitoring();
  }

  async loadPerformanceHistory() {
    try {
      const historyPath = '.claude/subagents/logs/performance-history.json';
      if (await this.fileExists(historyPath)) {
        const historyContent = await this.read(historyPath);
        const history = JSON.parse(historyContent);
        
        for (const [endpoint, data] of Object.entries(history)) {
          this.performanceHistory.set(endpoint, data);
        }
      }
      
      this.log('Performance history loaded');
    } catch (error) {
      this.error('Failed to load performance history', error);
    }
  }

  async checkDependencies() {
    try {
      // Check if Lighthouse is available
      try {
        await this.bash('lighthouse --version', 'Check Lighthouse availability');
        this.hasLighthouse = true;
      } catch (error) {
        this.hasLighthouse = false;
        this.log('Lighthouse not available - install with: npm install -g lighthouse');
      }
      
      // Check build tools
      const packageJson = await this.read('package.json');
      const packageData = JSON.parse(packageJson);
      
      this.buildTools = {
        hasWebpack: packageData.dependencies?.webpack || packageData.devDependencies?.webpack,
        hasVite: packageData.dependencies?.vite || packageData.devDependencies?.vite,
        hasCRA: packageData.dependencies?.['react-scripts'],
        hasNextJS: packageData.dependencies?.next || packageData.devDependencies?.next
      };
      
      this.log('Dependencies checked');
    } catch (error) {
      this.error('Failed to check dependencies', error);
    }
  }

  async initializeMonitoring() {
    try {
      // Set up performance monitoring infrastructure
      this.monitoringActive = true;
      
      // Create performance monitoring script
      await this.createPerformanceMonitoringScript();
      
      this.log('Performance monitoring initialized');
    } catch (error) {
      this.error('Failed to initialize monitoring', error);
    }
  }

  async createPerformanceMonitoringScript() {
    const monitoringScript = `// Performance monitoring script
// Auto-generated by Performance Auditor Agent

class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.observer = null;
    this.init();
  }

  init() {
    // Monitor Web Vitals
    this.observeWebVitals();
    
    // Monitor resource loading
    this.observeResourceTiming();
    
    // Monitor navigation timing
    this.observeNavigationTiming();
    
    // Send metrics periodically
    setInterval(() => this.sendMetrics(), 30000);
  }

  observeWebVitals() {
    // FCP - First Contentful Paint
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name === 'first-contentful-paint') {
          this.metrics.FCP = entry.startTime;
        }
      }
    }).observe({ entryTypes: ['paint'] });

    // FID - First Input Delay
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.metrics.FID = entry.processingStart - entry.startTime;
      }
    }).observe({ entryTypes: ['first-input'] });

    // CLS - Cumulative Layout Shift
    let clsValue = 0;
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
      this.metrics.CLS = clsValue;
    }).observe({ entryTypes: ['layout-shift'] });

    // LCP - Largest Contentful Paint
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.metrics.LCP = lastEntry.startTime;
    }).observe({ entryTypes: ['largest-contentful-paint'] });
  }

  observeResourceTiming() {
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'resource') {
          const resourceType = this.getResourceType(entry.name);
          if (!this.metrics.resources) this.metrics.resources = {};
          if (!this.metrics.resources[resourceType]) this.metrics.resources[resourceType] = [];
          
          this.metrics.resources[resourceType].push({
            name: entry.name,
            duration: entry.duration,
            transferSize: entry.transferSize,
            encodedBodySize: entry.encodedBodySize
          });
        }
      }
    }).observe({ entryTypes: ['resource'] });
  }

  observeNavigationTiming() {
    const navigation = performance.getEntriesByType('navigation')[0];
    if (navigation) {
      this.metrics.navigation = {
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.navigationStart,
        loadComplete: navigation.loadEventEnd - navigation.navigationStart,
        ttfb: navigation.responseStart - navigation.navigationStart
      };
    }
  }

  getResourceType(url) {
    if (url.includes('.js')) return 'javascript';
    if (url.includes('.css')) return 'stylesheet';
    if (url.match(/\\.(jpg|jpeg|png|gif|webp|svg)$/)) return 'image';
    if (url.match(/\\.(woff|woff2|ttf|otf)$/)) return 'font';
    return 'other';
  }

  sendMetrics() {
    // Send metrics to analytics endpoint
    if (Object.keys(this.metrics).length > 0) {
      fetch('/api/performance-metrics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          timestamp: Date.now(),
          url: window.location.href,
          metrics: this.metrics
        })
      }).catch(console.error);
    }
  }
}

// Initialize performance monitoring
if (typeof window !== 'undefined') {
  new PerformanceMonitor();
}`;

    const scriptPath = 'public/performance-monitor.js';
    await this.write(scriptPath, monitoringScript);
    this.log('Created performance monitoring script');
  }

  async performScheduledAudit() {
    this.log('Performing scheduled performance audit');
    
    try {
      // Quick performance check
      const quickAudit = await this.performQuickAudit();
      
      // Check for performance regressions
      const regressions = await this.detectPerformanceRegressions(quickAudit);
      
      if (regressions.length > 0) {
        this.log(`Found ${regressions.length} performance regressions`);
        await this.handlePerformanceRegressions(regressions);
      }
      
      // Update performance history
      await this.updatePerformanceHistory(quickAudit);
      
    } catch (error) {
      this.error('Failed to perform scheduled audit', error);
    }
  }

  async performQuickAudit() {
    const audit = {
      timestamp: new Date().toISOString(),
      bundleSize: await this.analyzeBundleSize(),
      dependencies: await this.analyzeDependencies(),
      imageOptimization: await this.checkImageOptimization(),
      codeQuality: await this.analyzeCodeQuality()
    };
    
    return audit;
  }

  async analyzeBundleSize() {
    try {
      // Check if build directory exists
      const buildDirs = ['build', 'dist', '.next'];
      let buildDir = null;
      
      for (const dir of buildDirs) {
        if (await this.fileExists(dir)) {
          buildDir = dir;
          break;
        }
      }
      
      if (!buildDir) {
        this.log('No build directory found - running build first');
        await this.bash('npm run build', 'Build project for analysis');
        buildDir = 'build';
      }
      
      // Analyze bundle files
      const jsFiles = await this.glob('*.js', buildDir);
      const cssFiles = await this.glob('*.css', buildDir);
      
      let totalJSSize = 0;
      let totalCSSSize = 0;
      
      for (const file of jsFiles) {
        const stats = await this.bash(`wc -c < "${file}"`, 'Get file size');
        totalJSSize += parseInt(stats.trim());
      }
      
      for (const file of cssFiles) {
        const stats = await this.bash(`wc -c < "${file}"`, 'Get file size');
        totalCSSSize += parseInt(stats.trim());
      }
      
      return {
        totalJSSize: Math.round(totalJSSize / 1024), // KB
        totalCSSSize: Math.round(totalCSSSize / 1024), // KB
        jsFiles: jsFiles.length,
        cssFiles: cssFiles.length,
        exceedsThreshold: totalJSSize / 1024 > this.performanceConfig.metrics.bundle.maxSize
      };
      
    } catch (error) {
      this.error('Failed to analyze bundle size', error);
      return { error: 'Bundle analysis failed' };
    }
  }

  async analyzeDependencies() {
    try {
      const packageJson = await this.read('package.json');
      const packageData = JSON.parse(packageJson);
      
      const dependencies = Object.keys(packageData.dependencies || {});
      const devDependencies = Object.keys(packageData.devDependencies || {});
      
      // Check for heavy dependencies
      const heavyDependencies = [
        'lodash', 'moment', 'core-js', '@babel/polyfill',
        'rxjs', 'three', 'd3', 'chart.js'
      ];
      
      const foundHeavyDeps = dependencies.filter(dep => 
        heavyDependencies.some(heavy => dep.includes(heavy))
      );
      
      // Check for duplicate functionality
      const duplicateChecks = [
        { packages: ['moment', 'date-fns', 'dayjs'], purpose: 'date manipulation' },
        { packages: ['lodash', 'ramda', 'underscore'], purpose: 'utility functions' },
        { packages: ['axios', 'fetch', 'node-fetch'], purpose: 'HTTP requests' }
      ];
      
      const duplicates = [];
      for (const check of duplicateChecks) {
        const found = check.packages.filter(pkg => dependencies.includes(pkg));
        if (found.length > 1) {
          duplicates.push({ purpose: check.purpose, packages: found });
        }
      }
      
      return {
        totalDependencies: dependencies.length,
        totalDevDependencies: devDependencies.length,
        heavyDependencies: foundHeavyDeps,
        duplicates,
        recommendations: this.generateDependencyRecommendations(foundHeavyDeps, duplicates)
      };
      
    } catch (error) {
      this.error('Failed to analyze dependencies', error);
      return { error: 'Dependency analysis failed' };
    }
  }

  generateDependencyRecommendations(heavyDeps, duplicates) {
    const recommendations = [];
    
    if (heavyDeps.includes('moment')) {
      recommendations.push('Replace moment.js with date-fns or dayjs for smaller bundle size');
    }
    
    if (heavyDeps.includes('lodash')) {
      recommendations.push('Use lodash-es or individual lodash functions to enable tree shaking');
    }
    
    for (const duplicate of duplicates) {
      recommendations.push(`Remove duplicate ${duplicate.purpose} libraries: ${duplicate.packages.join(', ')}`);
    }
    
    return recommendations;
  }

  async checkImageOptimization() {
    try {
      // Find image files
      const imageFiles = await this.grep('\\.(jpg|jpeg|png|gif|webp|svg)$', {
        glob: 'src/**/*',
        outputMode: 'files_with_matches'
      });
      
      let unoptimizedImages = 0;
      let largeImages = 0;
      let missingAltText = 0;
      
      // Check for Cloudinary optimization
      const cloudinaryImages = await this.grep('cloudinary.com', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      // Check for lazy loading
      const lazyLoadedImages = await this.grep('loading.*lazy', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      // Check for responsive images
      const responsiveImages = await this.grep('srcSet|sizes', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      // Analyze image usage in components
      const imageComponents = await this.grep('<img|<Image', {
        glob: 'src/**/*.tsx',
        outputMode: 'content'
      });
      
      // Check for missing alt text
      for (const line of imageComponents) {
        if (line.includes('<img') && !line.includes('alt=')) {
          missingAltText++;
        }
      }
      
      return {
        totalImageFiles: imageFiles.length,
        cloudinaryOptimized: cloudinaryImages.length > 0,
        lazyLoadedCount: lazyLoadedImages,
        responsiveCount: responsiveImages,
        missingAltText,
        recommendations: this.generateImageRecommendations({
          cloudinaryOptimized: cloudinaryImages.length > 0,
          lazyLoadedCount: lazyLoadedImages,
          missingAltText
        })
      };
      
    } catch (error) {
      this.error('Failed to check image optimization', error);
      return { error: 'Image optimization check failed' };
    }
  }

  generateImageRecommendations(imageData) {
    const recommendations = [];
    
    if (!imageData.cloudinaryOptimized) {
      recommendations.push('Implement Cloudinary for automatic image optimization');
    }
    
    if (imageData.lazyLoadedCount === 0) {
      recommendations.push('Add lazy loading to images for better performance');
    }
    
    if (imageData.missingAltText > 0) {
      recommendations.push(`Add alt text to ${imageData.missingAltText} images for accessibility`);
    }
    
    return recommendations;
  }

  async analyzeCodeQuality() {
    try {
      // Check for React best practices
      const memoUsage = await this.grep('React.memo|useMemo|useCallback', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      // Check for console logs in production code
      const consoleLogs = await this.grep('console\\.', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      // Check for inline styles
      const inlineStyles = await this.grep('style=\\{', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      // Check for large components
      const componentFiles = await this.glob('*.tsx', 'src/components');
      let largeComponents = 0;
      
      for (const file of componentFiles) {
        const content = await this.read(file);
        const lineCount = content.split('\\n').length;
        if (lineCount > 300) {
          largeComponents++;
        }
      }
      
      return {
        memoUsage,
        consoleLogs,
        inlineStyles,
        largeComponents,
        recommendations: this.generateCodeQualityRecommendations({
          memoUsage,
          consoleLogs,
          inlineStyles,
          largeComponents
        })
      };
      
    } catch (error) {
      this.error('Failed to analyze code quality', error);
      return { error: 'Code quality analysis failed' };
    }
  }

  generateCodeQualityRecommendations(codeData) {
    const recommendations = [];
    
    if (codeData.memoUsage < 5) {
      recommendations.push('Consider using React.memo, useMemo, and useCallback for performance optimization');
    }
    
    if (codeData.consoleLogs > 10) {
      recommendations.push('Remove console.log statements from production code');
    }
    
    if (codeData.inlineStyles > 5) {
      recommendations.push('Move inline styles to CSS classes or styled components');
    }
    
    if (codeData.largeComponents > 0) {
      recommendations.push(`Break down ${codeData.largeComponents} large components into smaller ones`);
    }
    
    return recommendations;
  }

  async detectPerformanceRegressions(currentAudit) {
    const regressions = [];
    
    // Check against previous audit
    const historyKey = 'latest';
    const previousAudit = this.performanceHistory.get(historyKey);
    
    if (!previousAudit) {
      this.log('No previous audit found for regression detection');
      return regressions;
    }
    
    // Check bundle size regression
    if (currentAudit.bundleSize.totalJSSize > previousAudit.bundleSize.totalJSSize * 1.1) {
      regressions.push({
        type: 'bundle-size',
        severity: 'medium',
        message: `JS bundle size increased by ${currentAudit.bundleSize.totalJSSize - previousAudit.bundleSize.totalJSSize}KB`,
        current: currentAudit.bundleSize.totalJSSize,
        previous: previousAudit.bundleSize.totalJSSize
      });
    }
    
    // Check dependency count regression
    if (currentAudit.dependencies.totalDependencies > previousAudit.dependencies.totalDependencies) {
      regressions.push({
        type: 'dependency-count',
        severity: 'low',
        message: `Added ${currentAudit.dependencies.totalDependencies - previousAudit.dependencies.totalDependencies} new dependencies`,
        current: currentAudit.dependencies.totalDependencies,
        previous: previousAudit.dependencies.totalDependencies
      });
    }
    
    return regressions;
  }

  async handlePerformanceRegressions(regressions) {
    for (const regression of regressions) {
      this.log(`Performance regression detected: ${regression.message}`);
      
      // Add to optimization queue
      this.optimizationQueue.push({
        type: regression.type,
        priority: regression.severity === 'high' ? 'critical' : 'medium',
        description: regression.message,
        timestamp: new Date().toISOString()
      });
    }
    
    // Process critical optimizations immediately
    const criticalOptimizations = this.optimizationQueue.filter(opt => opt.priority === 'critical');
    if (criticalOptimizations.length > 0) {
      await this.processCriticalOptimizations(criticalOptimizations);
    }
  }

  async processCriticalOptimizations(optimizations) {
    for (const optimization of optimizations) {
      this.log(`Processing critical optimization: ${optimization.description}`);
      
      switch (optimization.type) {
        case 'bundle-size':
          await this.optimizeBundleSize();
          break;
        case 'dependency-count':
          await this.auditDependencies();
          break;
      }
    }
  }

  async optimizeBundleSize() {
    try {
      // Suggest code splitting if not implemented
      const hasSuspense = await this.grep('Suspense|lazy', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      if (hasSuspense === 0) {
        this.log('Suggestion: Implement code splitting with React.lazy() and Suspense');
      }
      
      // Check for dynamic imports
      const hasDynamicImports = await this.grep('import\\(', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      if (hasDynamicImports === 0) {
        this.log('Suggestion: Use dynamic imports for route-based code splitting');
      }
      
    } catch (error) {
      this.error('Failed to optimize bundle size', error);
    }
  }

  async auditDependencies() {
    try {
      const analysis = await this.analyzeDependencies();
      
      for (const recommendation of analysis.recommendations) {
        this.log(`Dependency recommendation: ${recommendation}`);
      }
      
    } catch (error) {
      this.error('Failed to audit dependencies', error);
    }
  }

  async updatePerformanceHistory(audit) {
    try {
      this.performanceHistory.set('latest', audit);
      this.performanceHistory.set(audit.timestamp, audit);
      
      // Keep only last 30 days of history
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      
      for (const [key, data] of this.performanceHistory) {
        if (key !== 'latest' && new Date(data.timestamp) < thirtyDaysAgo) {
          this.performanceHistory.delete(key);
        }
      }
      
      // Save history
      const historyPath = '.claude/subagents/logs/performance-history.json';
      const historyData = Object.fromEntries(this.performanceHistory);
      await this.write(historyPath, JSON.stringify(historyData, null, 2));
      
    } catch (error) {
      this.error('Failed to update performance history', error);
    }
  }

  async handleKeywordTrigger(keyword) {
    this.log(`Handling keyword trigger: ${keyword}`);
    
    switch (keyword) {
      case 'performance':
        await this.performComprehensiveAudit();
        break;
      case 'optimize':
        await this.optimizePerformance();
        break;
      case 'lighthouse':
        await this.runLighthouseAudit();
        break;
      default:
        this.log(`No specific handler for keyword: ${keyword}`);
    }
  }

  async optimizePerformance() {
    this.log('Running performance optimization');
    
    try {
      // Process all pending optimizations
      for (const optimization of this.optimizationQueue) {
        await this.processOptimization(optimization);
      }
      
      // Clear queue
      this.optimizationQueue = [];
      
      this.log('Performance optimization complete');
      
    } catch (error) {
      this.error('Failed to optimize performance', error);
    }
  }

  async processOptimization(optimization) {
    this.log(`Processing optimization: ${optimization.description}`);
    
    switch (optimization.type) {
      case 'bundle-size':
        await this.optimizeBundleSize();
        break;
      case 'image-optimization':
        await this.optimizeImages();
        break;
      case 'dependency-cleanup':
        await this.cleanupDependencies();
        break;
      case 'code-splitting':
        await this.implementCodeSplitting();
        break;
    }
  }

  async optimizeImages() {
    this.log('Optimizing images');
    
    try {
      // Check for unoptimized images and suggest Cloudinary
      const imageOptimization = await this.checkImageOptimization();
      
      for (const recommendation of imageOptimization.recommendations) {
        this.log(`Image optimization: ${recommendation}`);
      }
      
    } catch (error) {
      this.error('Failed to optimize images', error);
    }
  }

  async cleanupDependencies() {
    this.log('Analyzing dependencies for cleanup opportunities');
    
    try {
      const analysis = await this.analyzeDependencies();
      
      if (analysis.duplicates.length > 0) {
        this.log('Duplicate dependencies found:');
        for (const duplicate of analysis.duplicates) {
          this.log(`  - ${duplicate.purpose}: ${duplicate.packages.join(', ')}`);
        }
      }
      
      if (analysis.heavyDependencies.length > 0) {
        this.log('Heavy dependencies found:');
        for (const dep of analysis.heavyDependencies) {
          this.log(`  - ${dep}`);
        }
      }
      
    } catch (error) {
      this.error('Failed to cleanup dependencies', error);
    }
  }

  async implementCodeSplitting() {
    this.log('Checking code splitting implementation');
    
    try {
      // Check current implementation
      const hasSuspense = await this.grep('Suspense', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      const hasLazy = await this.grep('React.lazy', {
        glob: 'src/**/*.tsx',
        outputMode: 'count'
      });
      
      if (hasSuspense === 0 || hasLazy === 0) {
        this.log('Code splitting not fully implemented');
        this.log('Suggestion: Implement React.lazy() for route-based code splitting');
        
        // Generate code splitting example
        const example = this.generateCodeSplittingExample();
        this.log('Code splitting example:');
        this.log(example);
      } else {
        this.log('Code splitting already implemented');
      }
      
    } catch (error) {
      this.error('Failed to check code splitting', error);
    }
  }

  generateCodeSplittingExample() {
    return `// Route-based code splitting example
import React, { Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';

// Lazy load components
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));
const Services = React.lazy(() => import('./pages/Services'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/services" element={<Services />} />
      </Routes>
    </Suspense>
  );
}`;
  }

  async runLighthouseAudit() {
    if (!this.hasLighthouse) {
      this.log('Lighthouse not available - skipping audit');
      return;
    }
    
    this.log('Running Lighthouse audit');
    
    try {
      // Run Lighthouse on development server
      const lighthouseCmd = `lighthouse http://localhost:3000 --output=json --quiet --chrome-flags="--headless"`;
      const result = await this.bash(lighthouseCmd, 'Run Lighthouse audit');
      
      const lighthouseData = JSON.parse(result);
      const scores = lighthouseData.lhr.categories;
      
      const auditResults = {
        performance: Math.round(scores.performance.score * 100),
        accessibility: Math.round(scores.accessibility.score * 100),
        bestPractices: Math.round(scores['best-practices'].score * 100),
        seo: Math.round(scores.seo.score * 100)
      };
      
      this.log('Lighthouse scores:');
      for (const [category, score] of Object.entries(auditResults)) {
        const threshold = this.performanceConfig.metrics.lighthouse[category]?.threshold || 90;
        const status = score >= threshold ? '✅' : '❌';
        this.log(`  ${category}: ${score}/100 ${status}`);
      }
      
      // Save detailed report
      const reportPath = '.claude/subagents/logs/lighthouse-report.json';
      await this.write(reportPath, JSON.stringify(lighthouseData.lhr, null, 2));
      
    } catch (error) {
      this.error('Failed to run Lighthouse audit', error);
    }
  }

  async performComprehensiveAudit() {
    this.log('Performing comprehensive performance audit');
    
    try {
      const auditReport = {
        timestamp: new Date().toISOString(),
        quickAudit: await this.performQuickAudit(),
        optimizationQueue: this.optimizationQueue,
        recommendations: []
      };
      
      // Run Lighthouse if available
      if (this.hasLighthouse) {
        try {
          await this.runLighthouseAudit();
        } catch (error) {
          this.log('Lighthouse audit failed, continuing with other checks');
        }
      }
      
      // Generate comprehensive recommendations
      auditReport.recommendations = await this.generateComprehensiveRecommendations(auditReport.quickAudit);
      
      // Save audit report
      const reportPath = '.claude/subagents/logs/performance-audit-comprehensive.json';
      await this.write(reportPath, JSON.stringify(auditReport, null, 2));
      
      this.log(`Comprehensive audit complete. Report saved to ${reportPath}`);
      
      // Update performance reports
      this.performanceReports.push(auditReport);
      
    } catch (error) {
      this.error('Failed to perform comprehensive audit', error);
    }
  }

  async generateComprehensiveRecommendations(quickAudit) {
    const recommendations = [];
    
    // Bundle size recommendations
    if (quickAudit.bundleSize.exceedsThreshold) {
      recommendations.push({
        category: 'bundle-size',
        priority: 'high',
        message: 'Bundle size exceeds recommended threshold',
        actions: [
          'Implement code splitting',
          'Remove unused dependencies',
          'Use dynamic imports',
          'Enable tree shaking'
        ]
      });
    }
    
    // Dependency recommendations
    if (quickAudit.dependencies.heavyDependencies.length > 0) {
      recommendations.push({
        category: 'dependencies',
        priority: 'medium',
        message: 'Heavy dependencies detected',
        actions: quickAudit.dependencies.recommendations
      });
    }
    
    // Image optimization recommendations
    if (quickAudit.imageOptimization.recommendations.length > 0) {
      recommendations.push({
        category: 'images',
        priority: 'medium',
        message: 'Image optimization opportunities found',
        actions: quickAudit.imageOptimization.recommendations
      });
    }
    
    // Code quality recommendations
    if (quickAudit.codeQuality.recommendations.length > 0) {
      recommendations.push({
        category: 'code-quality',
        priority: 'low',
        message: 'Code quality improvements available',
        actions: quickAudit.codeQuality.recommendations
      });
    }
    
    return recommendations;
  }
}

module.exports = PerformanceAuditorAgent;